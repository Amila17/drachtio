<!DOCTYPE html><html><head><title>Connect - High quality middleware for node.js</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link rel="stylesheet" href="style.css"><script src="jquery.js"></script><script src="docs.js"></script></head><body><div id="content"><h1>Connect</h1><div id="" class="comment"><h2></h2><div class="description"><p>Expose the middleware.</p></div><h3>Source</h3><pre><code>exports = module.exports = session;</code></pre></div><div id="exports.Store" class="comment"><h2>exports.Store</h2><div class="description"><p>Expose constructors.</p></div><h3>Source</h3><pre><code>exports.Store = Store;
exports.Cookie = Cookie;
exports.Session = Session;
exports.MemoryStore = MemoryStore;</code></pre></div><div id="warning" class="comment"><h2>warning</h2><div class="description"><p>Warning message for <code>MemoryStore</code> usage in production.</p></div><h3>Source</h3><pre><code>var warning = 'Warning: connection.session() MemoryStore is not\n'
  + 'designed for a production environment, as it will leak\n'
  + 'memory, and will not scale past a single process.';</code></pre></div><div id="session" class="comment"><h2>session()</h2><div class="description"><p>Session:</p>

<p>Setup session store with the given <code>options</code>.</p>

<p>Session data is <em>not</em> saved in the cookie itself, however<br />  cookies are used, so we must use the <a href="cookieParser.html">cookieParser()</a><br />  middleware <em>before</em> <code>session()</code>.</p>

<p>Examples:</p>

<pre><code>connect()
  .use(connect.cookieParser())
  .use(connect.session({ secret: 'keyboard cat', key: 'sid', cookie: { secure: true }}))
</code></pre>

<p>Options:</p>

<ul>
<li><code>key</code> cookie name defaulting to <code>connect.sid</code></li>
<li><code>store</code> session store instance</li>
<li><code>secret</code> session cookie is signed with this secret to prevent tampering</li>
<li><code>cookie</code> session cookie settings, defaulting to <code>{ path: '/', httpOnly: true, maxAge: null }</code></li>
<li><code>proxy</code> trust the reverse proxy when setting secure cookies (via "x-forwarded-proto")</li>
</ul>

<p>Cookie option:</p>

<p>By default <code>cookie.maxAge</code> is <code>null</code>, meaning no "expires" parameter is set<br /> so the cookie becomes a browser-session cookie. When the user closes the<br /> browser the cookie (and session) will be removed.</p>

<h2>req.session</h2>

<p>To store or access session data, simply use the request property <code>req.session</code>,<br /> which is (generally) serialized as JSON by the store, so nested objects<br /> are typically fine. For example below is a user-specific view counter:</p>

<pre><code>  connect()
    .use(connect.favicon())
    .use(connect.cookieParser())
    .use(connect.session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }}))
    .use(function(req, res, next){
      var sess = req.session;
      if (sess.views) {
        res.setHeader('Content-Type', 'text/html');
        res.write('&lt;p&gt;views: ' + sess.views + '&lt;/p&gt;');
        res.write('&lt;p&gt;expires in: ' + (sess.cookie.maxAge / 1000) + 's&lt;/p&gt;');
        res.end();
        sess.views++;
      } else {
        sess.views = 1;
        res.end('welcome to the session demo. refresh!');
      }
    }
  )).listen(3000);
</code></pre>

<h2>Session#regenerate()</h2>

<p>To regenerate the session simply invoke the method, once complete<br /> a new SID and <code>Session</code> instance will be initialized at <code>req.session</code>.</p>

<pre><code> req.session.regenerate(function(err){
   // will have a new session here
 });
</code></pre>

<h2>Session#destroy()</h2>

<p>Destroys the session, removing <code>req.session</code>, will be re-generated next request.</p>

<pre><code> req.session.destroy(function(err){
   // cannot access session here
 });
</code></pre>

<h2>Session#reload()</h2>

<p>Reloads the session data.</p>

<pre><code> req.session.reload(function(err){
   // session updated
 });
</code></pre>

<h2>Session#save()</h2>

<p>Save the session.</p>

<pre><code> req.session.save(function(err){
   // session saved
 });
</code></pre>

<h2>Session#touch()</h2>

<p>Updates the <code>.maxAge</code> property. Typically this is<br />  not necessary to call, as the session middleware does this for you.</p>

<h2>Session#cookie</h2>

<p>Each session has a unique cookie object accompany it. This allows<br /> you to alter the session cookie per visitor. For example we can<br /> set <code>req.session.cookie.expires</code> to <code>false</code> to enable the cookie<br /> to remain for only the duration of the user-agent.</p>

<h2>Session#maxAge</h2>

<p>Alternatively <code>req.session.cookie.maxAge</code> will return the time<br /> remaining in milliseconds, which we may also re-assign a new value<br /> to adjust the <code>.expires</code> property appropriately. The following<br /> are essentially equivalent</p>

<pre><code>var hour = 3600000;
req.session.cookie.expires = new Date(Date.now() + hour);
req.session.cookie.maxAge = hour;
</code></pre>

<p>For example when <code>maxAge</code> is set to <code>60000</code> (one minute), and 30 seconds<br />has elapsed it will return <code>30000</code> until the current request has completed,<br />at which time <code>req.session.touch()</code> is called to reset <code>req.session.maxAge</code><br />to its original value.</p>

<pre><code>req.session.cookie.maxAge;
// =&gt; 30000
</code></pre>

<p>Session Store Implementation:</p>

<p>Every session store <em>must</em> implement the following methods</p>

<ul>
<li><code>.get(sid, callback)</code></li>
<li><code>.set(sid, session, callback)</code></li>
<li><code>.destroy(sid, callback)</code></li>
</ul>

<p>Recommended methods include, but are not limited to:</p>

<ul>
<li><code>.length(callback)</code></li>
<li><code>.clear(callback)</code></li>
</ul>

<p>For an example implementation view the <a href="http://github.com/visionmedia/connect-redis">connect-redis</a> repo.</p></div><ul class="tags"><li><em>Object</em> options </li><li>returns <em>Function</em> </li></ul><h3>Source</h3><pre><code>function session(options){
  var options = options || {}
    , key = options.key || 'connect.sid'
    , store = options.store || new MemoryStore
    , cookie = options.cookie || {}
    , trustProxy = options.proxy
    , storeReady = true;

  // notify user that this store is not
  // meant for a production environment
  if ('production' == env && store instanceof MemoryStore) {
    console.warn(warning);
  }

  // generates the new session
  store.generate = function(req){
    req.sessionID = uid(24);
    req.session = new Session(req);
    req.session.cookie = new Cookie(cookie);
  };

  store.on('disconnect', function(){ storeReady = false; });
  store.on('connect', function(){ storeReady = true; });

  return function session(req, res, next) {
    // self-awareness
    if (req.session) return next();

    // Handle connection as if there is no session if
    // the store has temporarily disconnected etc
    if (!storeReady) return debug('store is disconnected'), next();

    // pathname mismatch
    if (0 != req.originalUrl.indexOf(cookie.path || '/')) return next();

    // backwards compatibility for signed cookies
    // req.secret is passed from the cookie parser middleware
    var secret = options.secret || req.secret;

    // ensure secret is available or bail
    if (!secret) throw new Error('`secret` option required for sessions');

    // parse url
    var originalHash
      , originalId;

    // expose store
    req.sessionStore = store;

    // grab the session cookie value and check the signature
    var rawCookie = req.cookies[key];

    // get signedCookies for backwards compat with signed cookies
    var unsignedCookie = req.signedCookies[key];

    if (!unsignedCookie && rawCookie) {
      unsignedCookie = utils.parseSignedCookie(rawCookie, secret);
    }

    // set-cookie
    res.on('header', function(){
      if (!req.session) return;
      var cookie = req.session.cookie
        , proto = (req.headers['x-forwarded-proto'] || '').split(',')[0].toLowerCase().trim()
        , tls = req.connection.encrypted || (trustProxy && 'https' == proto)
        , isNew = unsignedCookie != req.sessionID;

      // only send secure cookies via https
      if (cookie.secure && !tls) return debug('not secured');

      // long expires, handle expiry server-side
      if (!isNew && cookie.hasLongExpires) return debug('already set cookie');

      // browser-session length cookie
      if (null == cookie.expires) {
        if (!isNew) return debug('already set browser-session cookie');
      // compare hashes and ids
      } else if (originalHash == hash(req.session) && originalId == req.session.id) {
        return debug('unmodified session');
      }

      var val = 's:' + signature.sign(req.sessionID, secret);
      val = cookie.serialize(key, val);
      debug('set-cookie %s', val);
      res.setHeader('Set-Cookie', val);
    });

    // proxy end() to commit the session
    var end = res.end;
    res.end = function(data, encoding){
      res.end = end;
      if (!req.session) return res.end(data, encoding);
      debug('saving');
      req.session.resetMaxAge();
      req.session.save(function(err){
        if (err) console.error(err.stack);
        debug('saved');
        res.end(data, encoding);
      });
    };

    // generate the session
    function generate() {
      store.generate(req);
    }

    // get the sessionID from the cookie
    req.sessionID = unsignedCookie;

    // generate a session if the browser doesn't send a sessionID
    if (!req.sessionID) {
      debug('no SID sent, generating session');
      generate();
      next();
      return;
    }

    // generate the session object
    var pause = utils.pause(req);
    debug('fetching %s', req.sessionID);
    store.get(req.sessionID, function(err, sess){
      // proxy to resume() events
      var _next = next;
      next = function(err){
        _next(err);
        pause.resume();
      };

      // error handling
      if (err) {
        debug('error %j', err);
        if ('ENOENT' == err.code) {
          generate();
          next();
        } else {
          next(err);
        }
      // no session
      } else if (!sess) {
        debug('no session found');
        generate();
        next();
      // populate req.session
      } else {
        debug('session found');
        store.createSession(req, sess);
        originalId = req.sessionID;
        originalHash = hash(sess);
        next();
      }
    });
  };
};</code></pre></div><div id="hash" class="comment"><h2>hash()</h2><div class="description"><p>Hash the given <code>sess</code> object omitting changes<br />to <code>.cookie</code>.</p></div><ul class="tags"><li><em>Object</em> sess </li><li>returns <em>String</em> </li></ul><h3>Source</h3><pre><code>function hash(sess) {
  return crc32.signed(JSON.stringify(sess, function(key, val){
    if ('cookie' != key) return val;
  }));
}</code></pre></div></div><ul id="menu"><li><a href="#"></a></li><li><a href="#exports.Store">exports.Store</a></li><li><a href="#warning">warning</a></li><li><a href="#session">session()</a></li><li><a href="#hash">hash()</a></li></ul></body></html>