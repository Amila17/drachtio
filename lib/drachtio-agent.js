'use strict' ;

const Emitter = require('events');
const debug = require('debug')('drachtio:agent');
const WireProtocol = require('./wire-protocol') ;
const SipMessage = require('drachtio-sip').SipMessage ;
const Request = require('./request') ;
const Response = require('./response') ;
const DigestClient = require('./digest-client') ;
const noop = require('node-noop').noop;
const winston = require('winston') ;
const CR = '\r' ;
const CRLF = '\r\n' ;

const defer = typeof setImmediate === 'function' ? setImmediate : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)); } ;

class DrachtioAgent extends Emitter {

  constructor( callback ) {
    super();

    this.puntUpTheMiddleware = callback ;
    this.params = new Map() ;


    //any request message awaiting a response from the drachtio server
    this.pendingRequests = new Map() ;

    //any sip request generated by us awaiting a final response from the server
    this.pendingSipRequests = new Map() ;

    //any sip request generated by us that we are resending with Authorization header
    this.pendingSipAuthRequests = new Map() ;

    //any sip INVITE we've received that we've not yet generated a final response for
    this.pendingNetworkInvites = new Map() ;

    // a reliable provisional response or 200 OK to INVITE that is waiting on a PRACK/ACK
    this.pendingAckOrPrack = new Map() ;

    this.cdrHandlers = new Map() ;

    this.verbs = new Map() ;
  }

  get idle () {
    let pendingCount = this.pendingRequests.size ;
    let pendingSipCount = this.pendingSipRequests.size ;
    let pendingAckOrPrack = this.pendingAckOrPrack.size ;
    if( pendingCount > 0 ) {
      console.log(`count of pending requests: ${pendingCount}: ${JSON.stringify(this.pendingRequests)}`) ;
    }
    if( pendingSipCount > 0 ) {
      console.log(`count of pending sip requests: ${pendingSipCount}: ${JSON.stringify(this.pendingSipRequests)}`) ;
    }
    if( pendingAckOrPrack > 0 ) {
      console.log(`count of pending ack/prack: ${pendingAckOrPrack}: ${JSON.stringify(this.pendingAckOrPrack)}`) ;
    }

    return pendingCount + pendingSipCount + pendingAckOrPrack === 0 ;    
  }

  connect( opts ) {
    this.secret = opts.secret ;
    this.label = opts.label || '' ;
    this.methods = opts.methods || [] ;

    if( this._logger ) {
      opts.logger = this._logger ;
    }

    this.wp = new WireProtocol( opts ) ;

    // pass on some of the socket events
    ['reconnecting','close','error'].forEach( (evt) => {
      this.wp.on(evt, (...args) => {
        this.emit( evt, ...args);
      }) ;
    }) ;

    this.wp.on('connect', this._onConnect.bind(this)) ;
    this.wp.on('msg', this._onMsg.bind(this)) ;
  }

  on(event, fn) {
    //cdr events are handled through a different mechanism - we register with the server
    if( 0 === event.indexOf('cdr:') ) {
      this.cdrHandlers.set(event.slice(4), fn) ;
      this.route(event) ;
    }
    else {
      //delegate to EventEmitter
      Emitter.prototype.on.apply( this, arguments )  ;  
    }
  } 
  
  sendMessage( msg, opts ) {
    let m = msg ;
    opts = opts || {} ;

    debug(`opts: ${JSON.stringify(opts)}`);

    if( opts && (opts.headers || opts.body ) ) {
      m = new SipMessage( msg ) ;
      for( var hdr in (opts.headers || {}) ) { 
        m.set(hdr, opts.headers[hdr]) ; 
      }
      if( opts.body ) { m.body = opts.body ; }
    }

    let s = `sip|${opts.stackTxnId || ''}|${opts.stackDialogId || ''}${CRLF}${m.toString()}`;
    debug(`s: ${s}`);

    return this.wp.send( s ) ; 
  } 

  _normalizeParams(uri, options, callback) {
  
    if (typeof uri === 'undefined' ) {
      let err = new Error('undefined is not a valid request_uri or options object.') ;
      console.error( err.stack ) ;
      throw err ;
    }

    // request( request_uri, options, callback, ..)
    if (options && typeof options === 'object' ) {
      options.uri = uri ;
    } 
    // request( request_uri, callback, ..)
    else if (typeof uri === 'string') {
      options = {uri:uri } ;
    }
    // request( option, callback, ..) 
    else {
      callback = options ;
      options = uri ;
      uri = options.uri; 
    }
    callback = callback || noop ;

    options.method = options.method.toUpperCase() ;

    return { uri: uri, options: options, callback: callback } ;
  } 

  _makeRequest( params ) {

    //allow for requests within a dialog, where caller does not need to supply a uri
    if( !params.options.uri && !!params.options.stackDialogId ) {
      params.options.uri = 'sip:placeholder' ;
    } 

    let m = new SipMessage(params.options) ;

    //new outgoing request 
    let msg = `sip|${params.options.stackTxnId || ''}|${params.options.stackDialogId || ''}${CRLF}${m.toString()}` ;
    var msgId = this.wp.send(msg) ;

    this.pendingRequests.set( msgId, (token, msg) => {
      if( token[0] === 'OK') {
        var transactionId = token[7] ;
        var meta = {
          source: token[1],
          address: token[4],
          port: token[5],
          protocol: token[3],
          time: token[6],
          transactionId: transactionId
        } ;

        var req = new Request( new SipMessage( msg ), meta ) ;
        req.agent = this ;
        if( !!params.options.auth ) {
          req.auth = params.options.auth ;
          req._originalParams = params ;
        }

        //Note: unfortunately, sofia (the nta layer) does not pass up the 200 OK response to a CANCEL
        //so we are unable to route it up to the application.
        //Therefore, we can't allocate this callback since it would never be called or freed
        if( params.options.method !== 'CANCEL') {
          this.pendingSipRequests.set( transactionId,  {
            req: req
          }) ;       
        }

        params.callback( null, req ) ;

      }
      else {
        params.callback(token[1] || 'request failed') ;
      }
    });
  }

  request(request_uri, options, callback) {
    let params = this._normalizeParams(request_uri, options, callback) ;
    return this._makeRequest( params ) ;
  } 

  sendResponse( res, opts, callback, fnAck ) {
    debug(`agent#sendResponse: ${JSON.stringify(res.msg)}`);
    let msgId = this.sendMessage( res.msg, Object.assign( {stackTxnId: res.req.stackTxnId}, opts) ) ;
    if( callback || fnAck ) {

      this.pendingRequests.set( msgId, (token, msg, meta) => {
        this.pendingRequests.delete( msgId ) ;
        if( 'OK' !== token[0] ) { return callback(token[1]) ; }
        let responseMsg = new SipMessage(msg) ;
        res.meta = meta ;
        if( callback ) { 
          callback(null, responseMsg ) ;
        }

        // for reliable provisional responses or does caller want to be notified on receipt of prack / ack ?
        if( fnAck && typeof fnAck === 'function' && (responseMsg.has('RSeq') || res.status === 200 ) ) {
          this.pendingAckOrPrack.set( meta.dialogId, fnAck ) ;
        }
      }) ; 
    }
    if( res.statusCode >= 200 ) { 
      defer( function() { 
        res.finished = true ;
        res.emit('finish'); 
      }); 

      // clear out pending incoming INVITEs when we send a final response
      if( res.req.method === 'INVITE') {
        let callId = res.get('call-id') ;
        this.pendingNetworkInvites.delete( callId ) ;
        debug(`Agent#sendResponse: deleted pending invite for call-id ${callId}, there are now ${this.pendingNetworkInvites.size} pending invites`);
      }
    }
  } 

  sendAck( method, dialogId, req, res, opts, callback ) {
    let m = new SipMessage() ;
    m.method = method ;
    m.uri = req.uri ;
    opts = opts || {} ;

    Object.assign( opts, {stackDialogId: dialogId}) ;

    let msgId = this.sendMessage( m, opts ) ;
    if( callback ) {
      this.pendingRequests.set( msgId, (token, msg /*, meta */) => {
        if( 'OK' !== token[0] ) { 
          return callback(token[1]) ; 
        } 
        callback(null, new SipMessage(msg) ) ;
      }) ;
    }
  } 

  proxy( req, opts, callback ) {

    var m = new SipMessage({
      uri: opts.destination[0],
      method: req.method
    }) ;

    if( opts.headers ) {
      for( var hdr in (opts.headers || {}) ) { 
        m.set(hdr, opts.headers[hdr]) ; 
      }
    }

    let msg = `proxy|${opts.stackTxnId}|${(opts.remainInDialog ? 'remainInDialog' : '')}|${(opts.fullResponse ? 'fullResponse' : '')}|${(opts.followRedirects ? 'followRedirects' : '')}|${(opts.simultaneous ? 'simultaneous' : 'serial')}|${opts.provisionalTimeout}|${opts.finalTimeout}|${opts.destination.join('|')}${CRLF}${m.toString()}` ;

    var msgId = this.wp.send( msg ) ;
    this.pendingRequests.set( msgId, callback ) ;
  } 

  set(prop, val) {

    switch( prop ) {
      case 'api logger':
        if( !!val ) {
          let opts = {} ;
          opts['string' === typeof val ? 'filename' : 'stream'] = val ;
          winston.configure({
            transports: [
              new (winston.transports.File)(opts)
            ]
          }) ;
          this._logger = winston.info ;
          if( !!this.wp ) {
            this.wp.setLogger( this._logger ) ;
          } 
        }
        else {
          this._logger = null ;
          if( !!this.wp ) {
            this.wp.removeLogger() ;
          }
        }
        break ;
      case 'handler':
        this.puntUpTheMiddleware = val ;
        break ;

      default:
        this.params.set( prop, val ) ;
        break ;
    }
  } 

  get(prop) {
    return this.params.get( prop ) ;
  } 

  route( verb ) {
    if( this.verbs.has( verb ) ) { throw new Error('duplicate route request for ' + verb) ; }
    this.verbs.set( verb,  { sent: false }) ;

    if( !this.authenticated ) { return ; }
    
    this.routeVerbs(this) ;
  }

  routeVerbs() {
    for( let verb of this.verbs) {
      if( verb[1].sent === true ) {
        continue ;
      }

      verb[1] = {
        sent: true,
        acknowledged: false,
        rid: this.wp.send('route|' + verb[0])
      } ;
    }
  }

  resetVerbs() {
    for( let verb in this.verbs ) {
      verb[1].sent = false ;
    }
  } 

  disconnect() {
    this.wp.disconnect() ;
  } 

  _onConnect() {
    let msgId = this.wp.send('authenticate|' + this.secret + '|' + this.label ) ;
    this.pendingRequests.set(msgId, (response) => {
      this.authenticated = ('OK' === response[0]) ;
      if( this.authenticated ) {
        this.ready = true ;
        this.set('hostport', response[1]) ;
        debug('sucessfully authenticated, hostport is ', response[1]) ;
        this.routeVerbs() ;

        //hack: attempt to have our route requests go through before we announce we're connected
        //not sure this is relevant for production, but in test scenarios we fire into tests as
        //soon as connected, and in the case of the cdr tests we got intermittent failures resulting
        //from not having routed cdr:start etc before the calls started arriving
        setTimeout( () => {
          this.emit('connect', null, response[1]) ;
        }, 100) ;

      }
      else {
        this.emit('connect', 'failed to authenticate to server') ;
      }
    }) ;
  }

  _onMsg( msg ) {
    let pos = msg.indexOf(CR) ;
    let leader = -1 === pos ? msg : msg.slice(0,pos) ;
    let token = leader.split('|') ;
    let res, sr, rawMsg ;
    
    switch( token[1] ) {
    case 'sip':
      rawMsg = msg.slice( pos+2 ) ;
      let sipMsg = new SipMessage( rawMsg ) ;
      let _x, source, protocol, address, port, time, transactionId, dialogId ;
      [_x, _x, source, _x, protocol, address, port, time, transactionId, dialogId ] = token ;
      let meta = { source, address, port, protocol, time, transactionId, dialogId } ;
      debug(`tokens: ${JSON.stringify(token)}`);

      if( token.length > 9 ) {

        if( 'network' === source && sipMsg.type === 'request' ) {

          //handle CANCELS by locating the associated INVITE and emitting a 'cancel' event
          var callId = sipMsg.get('call-id') ;
          if( 'CANCEL' === sipMsg.method && this.pendingNetworkInvites.has(callId) ) {
            this.pendingNetworkInvites.get(callId).req.emit('cancel') ;
            this.pendingNetworkInvites.delete(callId) ;
            debug('Agent#handle - emitted cancel event for INVITE with call-id %s, remaining count of invites in progress: %d', 
              callId, this.pendingNetworkInvites.size ) ;
            return ;
          }

          debug(`DrachtioAgent#_onMsg: meta: ${JSON.stringify(meta)}`);

          var req = new Request( sipMsg, meta) ;
          res = new Response() ;
          req.res = res ;
          res.req = req ;
          req.agent = res.agent = this ;

          if( 'INVITE' === req.method ) {
            this.pendingNetworkInvites.set(callId, { req, res }) ;
            debug('Agent#handle: tracking an incoming invite with call-id %s, currently tracking %d invites in progress', 
              callId, this.pendingNetworkInvites.size ) ;     
          }
          else if( ('PRACK' === req.method || 'ACK' === req.method) && this.pendingAckOrPrack.has( dialogId ) ) {
            var fnAck = this.pendingAckOrPrack.get(dialogId);
            this.pendingAckOrPrack.delete(dialogId);
            fnAck() ;
          }

          this.puntUpTheMiddleware( req, res ) ;
        }
        else if( 'network' === source ) {
          debug(`received sip response`);
          if( this.pendingSipRequests.has( transactionId ) ) {
            sr = this.pendingSipRequests.get(transactionId) ;
            res = new Response(this) ;
            res.msg = sipMsg ;
            res.meta = meta ;
            res.req = sr.req ;

            debug('Agent#handle: got a response with status: %d', res.status) ;

            if( res.status >= 200 ) {
              this.pendingSipRequests.delete(transactionId)  ;
            }

            //prepare a function to be called for prack or ack, if appropriate
            var ack = noop ;
            if( res.status >= 200 && res.req.method === 'INVITE') {
              ack = Response.prototype.sendAck.bind( res, token[9]) ;
            }
            else if( res.status > 100 && res.status < 200 ) {
              var prackNeeded = res.get('RSeq');
              if( prackNeeded ) {
                ack = Response.prototype.sendPrack.bind( res, token[9]) ;
              }
            }
            // If its a challenge and the user supplied username and password, automatically handle it
            var cid = res.msg.headers['call-id']; 
            if( this.pendingSipAuthRequests.has(cid) ) {
              this.pendingSipAuthRequests.delete(cid) ;

            }
            else if( (401 === res.status || 407 === res.status) && (!!res.req.auth) ) {
              this.pendingSipAuthRequests.set(cid, true) ;
              var client = new DigestClient( res ) ;
              client.authenticate( function(err, req) {
                // move all listeners from the old request to the new one we just generated
                res.req.listeners('response').forEach( function(l) {
                  req.on('response', l) ;
                }) ;
                res.req.emit('authenticate', req) ;
              }) ;
              return ;
            }
            sr.req.emit('response', res, ack ) ;                    
          }
        }         
      }

      break ;

    case 'response':
      var rId = token[2] ;
      if( this.pendingRequests.has( rId ) ) {
        if( -1 !== pos ) { rawMsg = msg.slice(pos+2) ; }
        var meta2 = {
          source: token[4],
          address: token[7],
          port: token[8],
          protocol: token[6],
          time: token[9],
          transactionId: token[10],
          dialogId: token[11]
        } ;
        var fn = this.pendingRequests.get(rId).bind( this, token.slice(3), rawMsg, meta2 ) ;
        if( 'continue' !== token[12] ) { 
          this.pendingRequests.delete(rId) ; 
        }
        fn() ;
      }
      break ;

    case 'cdr:attempt':
    case 'cdr:start':
    case 'cdr:stop':
      var cdrEvent = token[1].slice(4)  ;
      var msgSource = token[2] ;
      var msgTime = token[3] ;
      rawMsg = msg.slice( pos+2 ) ;
      var cdrSipMsg = new SipMessage( rawMsg ) ;
      var args = [msgSource, msgTime] ;
      if( cdrEvent !== 'attempt') { args.push( token[4] ) ; }
      args.push( cdrSipMsg ) ;

      if( this.cdrHandlers.has(cdrEvent) ) {
        this.cdrHandlers.get(cdrEvent).apply( this, args ) ;
      }
      break ;

    default:
      throw new Error('unexpected message with type: ' + token[1]) ;    
    }
  } 
} 

DrachtioAgent.prototype.uac = DrachtioAgent.prototype.request ; // alias

module.exports = DrachtioAgent ;